---
layout: post
title:  키 관리와 해쉬 함수 - 정보보호이해 3강
date:   2099-03-05 +0900
categories: security
---

## 키 관리 및 키 분배 프로토콜(이해 설명)
### 1. 키관리
* 암호시스템에서 사용되는 암호학적 키들을 안전하게 다루기 위한 일련의 절차
키생명주기(생성-등록-확인-분배-설치-저장-파생-보존-취소-말소-폐기)
1. 키분류
* 세션키 : 비밀키 암호에 사용되는 키(암호화, 복호화)
* 키 암호화키 : 세션키 설정, 저장에 사용되는 비밀키/개인키(세션키 만드는 역할)
* 마스터키 : 최상위의 키
2. 용어
* 생성 : **강한 안전성**을 가진 키를 **안전하게 생성**할 수 있는 절차
* 등록 : **키**와 **사용자를 연결**시켜주는 서비스로 키 등록기관이 제공하는 기능
* 키확인서 생성 : 공개키와 사용자의 연관성을 보장하는 것. 인증기관이 제공
* 키 분배 : 인가된 사용자들에게 키 관리 정보 객체들을 안전하게 제공해주는 일련의 절차 제공
* 키 설치 : 사용하기전에 필요한 절차. 설비 내에서 키가 위험하지 않은 방식으로 배치
* 키 복구 : (키 분실 상황)암호문 해독할 수 있는 키. 제3자에게 위탁시키고
* 키 저장 : 안전하게 저장
* 키 파생 : 비밀 근원 키(마스터키 등) 다른 새로온 세션키를 만드는 것
* 키 보관 : 
* 키 취소 :
* 키 말소 : 키와 사용자의 연결을 단절
* 키 폐기 :
### 2. 키 설정(Establishment)
* 키 만드는 과정
* 키 공유(Agreement)
    - 둘 이상의 참여자가 Agreement해서(Not 일방적) 공개된 통신로 비밀키를 설정하는 기술
    - 어느 한 쪽에서 독립적으로 비밀정보를 미리 결정하지 않는다
    (예) DH 키 공유 프로토콜
* 키 전송(Transport)
    - 한 사용자/기관이 비밀키 설정하고 다른 사용자에게 안전하게 키를 전달하는 기술
    (예) KEM( Key Encapsulation Mechanism )
* 키 유도(Key Derivation Functionkey)
    - 비밀정보(마스터키, 패스워드, 키공유)를 받은 후에 그것을 직접 사용하는 것이 아니라,그것으로 부터 각종 정보보호 알고리즘 실행을 위해서 필요로 하는 다양한 키들(세션키, 인증키등 Keying material)을 유도해내는 함수/메카니즘
### 3. 키 분배프로토콜
1. 키 사전 분배(Key Pre-distribution)
    - 신뢰하는 키 관리 기관(TA trusted authority, TTA third TA)
    TA가 사전에 사용자에게 비밀 경로를 통해서 임의의 키를 전달하는 방법
    * TA와 모든 사용자 사이에 안전한 통로가 필요함
    * 사용자가 많은 경우 많은 키를 관리해야 하는 문제점
    - n명의 사용자가 있다면 각 사용자는 n-1가지 키를 관리해야 하며( 본인 제외한 모든 사용자 ) TA는 총 n(n-1)/2 nC2가지 키를 관리해야 하므로 매우 복잡하며 관리비용이 많이 듬
2. 분배 프로토콜 #1 중앙집중식 키 분배
> 사용자 쌍방 간에 비밀통신을 원할 때마다 키관리기관인 키분배센터(KDC) 또는 TA(TTA)에 의하여 새로운 키(세션키)가 분배되는 방식
    - Kerberos
    - DH, STS, MTI
    - Girault(지로) 키 공유 프로토콜 / 지로-푸파르 프로토콜 (Girault-Poupard Protocol) 1983년

**Kerberos** 키 분배
  : 3자(사용자, KDC/TA, B) 대칭키 암호 방식 기반
  * 비밀 네트워크 = 암호화 통신
  1. A가 B의 세션키를 KDC/TA에 의뢰
  2. KDC/TA에 m1, m2를 A에게 전송 (m1=eKa(K,ID(B),T,L) , m2=eKb(K,ID(A),T,L))
  3. A가 Ka로 m1을 복호하여 K(=Kab), ID(B), T, L을 얻은 후 m3,m2를 B에게 전송 (m3=eK(D(A),T), m2=복호안한 그대로)
  4. B는 m3, m2 복호화하여 A가 보낸 D(A), T와 K, ID(A), T, L을 확인하고 m4를 A에게 회신 ( m4=eK(T+1))

DH 키 공유(=not분배)
> TA/KDC가 키를 생성해서 분배해 주는 것이 아니라, 사용자가 공개 정보를 이용해서 키를 만들어 공유하게 하기 때문에

  : TA/KDC가 공개키 목록을 갖고 있는 상황에서 키 공유
  1. A가 B에게 세션키 요청 (g(x) mod n)
  2. B는 B의 공인인증서를 A에게 회신
  3. A는 받은 B의 공인인증서를 TA/KDC에게 확인. B도 A의 공인인증서를 TA/KDC에게 확인

## 난수발생기와 키유도함수
### 1.난수 Random number
> 주어진 구간에서 통계적으로 독립, 예측 불가능하며, 편중되지 않은 수
* 독립 : 이전 출력된 값이 다음 출력될 수에 영향을 미치지 않는 것
* 예측불가능 : 이전 출력을 안다고 해도 다음 출력될 수를 예측할 수 없는 것
* 편중되지 않음: 특정한 수가 나타날 확률이 더 높지 않은 것

**실난수** True Random Number
> 물리적인 과정이나 자연에 의하여 생성되는 잡음원noise으로부터 얻어지는 난수
예) thermal noise, white noise, 주사위, lotto

**의사난수** PseudoRandom Number
> 실난수와 구별할 수 있는 효율적인 알고리즘이 존재하지 않는 만든 난수
> (실난수와 구별하기 어렵다. 효율적으로 구별할 알고리즘을 찾기 어렵다)
초기값seed로 부터 결정적 알고리즘에 의해 나온 난수
예) 블록암호 이용한 난수발생기, Hash 함수를 이용한 난수발생기, ANSI X9.17, FIPS 186-2

### 2. 난수발생기 RN Generator
**RNG**
* 물리적 현상의 랜덤성을 이용하여 Non-deterministic source(Entropy Source) 사용하여 비트 수열 생성( 주사위, 동전, 로또 번호 추출기 )
    - 비결정논적 난수발생기(BitGenerator NRBG)
    - PRNG pseudo random number generator
    **seed로 부터 PRNG를 생성하는 과정**
        Entropy source - TRNG - (seed) - PRNG - Pseudo random bit generator
        ("Entropy source - TRNG - seed" 과정으로 Entropy source를 얻기 어렵다. 카드처럼 작은 경우)
        TRNG : True RNG
**PRNG**
    - **DRBG**(Deterministic Random BitGenerator) 또는 DRNG 결정론적 난수발생기
        CTR_DRBG, Hash_DRBG, HMAC_DRBG, ANSI X9.17, FIPS 186-2
    - 짧은 길이의 seed값을 입력하여 결정론적 알고리즘에 의해 의사난수를 생성함
    - 상대적으로 Entropy는 낮지만 충분한 안전성을 제공함(결정론적 알고리즘이 안전하다면)
    - PRBG의 안전성은 Seed값에 의존한다
    - Seed값으로 RNG의 출력 비트를 사용
    * 논문 참조 [NIST SP800-90Ar1 DRBG를 이용한 RNG 활용](https://csrc.nist.gov/pubs/sp/800/90/a/r1/final)

**결정론적 알고리즘**
```
    **결정론적 난수 발생기(DRBG)**는 결정론적 알고리즘을 사용하여 난수와 유사한 값을 생성하는 함수입니다. 일반적으로 선형 합동법, 블룸 필터, 암호화 해시 함수 등이 사용됩니다.

    결정론적 알고리즘은 동일한 입력값에 대해 항상 동일한 출력값을 생성하는 알고리즘입니다. 즉, 과거 값을 기반으로 미래 값을 예측할 수 있습니다.

    따라서 결정론적 난수 발생기는 결정론적 알고리즘이라고 할 수 있습니다. 하지만, DRBG는 암호학적 해시 함수와 같은 비선형적인 알고리즘을 사용하여 출력값을 예측하기 어렵게 만듭니다. 또한, 엔트로피 소스와 시드를 사용하여 초기값을 설정함으로써 난수성을 높입니다.

    **선형 합동법, 블룸 필터, 암호화 해시 함수**는 모두 결정론적 알고리즘입니다.

    **선형 합동법**은 이전 값에 대한 선형 연산을 통해 다음 값을 생성하는 알고리즘입니다. 간단하지만 예측 가능성이 높아 보안성이 낮다는 단점이 있습니다.

    **블룸 필터**는 비트 배열과 해시 함수를 사용하여 데이터의 존재 여부를 판단하는 알고리즘입니다. 난수 생성에 직접 사용되지는 않지만, 암호화 프로토콜 등에 활용됩니다.

    **암호화 해시 함수**는 입력 데이터를 고정 길이의 값으로 변환하는 알고리즘입니다. 암호화 해시 함수는 비선형적이고 충돌 가능성이 낮기 때문에 DRBG에 적합합니다.

    결론적으로, 결정론적 난수 발생기는 결정론적 알고리즘을 사용하지만, 엔트로피 소스와 시드를 사용하여 난수성을 높입니다. 또한, 선형 합동법, 블룸 필터, 암호화 해시 함수는 모두 결정론적 알고리즘입니다.
```

**KDF 키유도함수**
    비밀정보()+공개된 정보(salt등)로 부터 여러개의 Key를 생성
    - 설정된 키로부터 추가적인 키를 얻기 위해
    - 비밀정보(마스터키)를 직접 사용되지 않게
    - 마스터키(키유도키)+외부 입력값을 통해 키 생성
    - 세션키, 인증키, 암호화키 등을 생성
    : 해시함수 기반 - 무선랜의 KDF
    : 블록암호 기반 - 무선 3GPP
    : 패스워드 기반 - PKCS#5

## 해쉬함수
> 블록체인에서 사용하는 해시함수
### 활용
    1. 데이터 비교에 사용 = 데이터 고유성 확인 효율성
    2. 분산장부(데이터) 블록 위변조 확인 = 무결성 유지
    3. 해시참조 = 정보 결합 ( ?NONCE - 블록 보디)
    4. 데이터의 효율적인 저장
    5. 작업증명 Proof of Work (해시퍼즐 이용, NONCE 사용?)
### 일방향 함수 One-way Function
    : 변수를 통해 함수 값은 구할 수 있지만, 함수 값에서 변수를 구하기는 어렵다
    (예, 이산대수문제 인수분해문제)
    - 공개키 암호의 핵심적인 개념
    - 대부분의 보안 프로토콜에서 사용됨( 특히 전자서명 )
### 충돌 Collision
    : 서로 다른 입력 값에 대하여 동일한 해시 값이 출력되는 경우

### 해시 함수
    : 임의의 **유한** 길이의 입력 값을 **고정된** 크기의 출력값으로 바꾸는 함수
    (MD5, HAS160, SHA3)
    => 해시값, 해시코드, 메세지다이제스트, 인증자, 데이터지문, 해시체크섬
### 암호학적 성질
    1. 계산용이성
    2. 일방향성(역상저항성 Preimage Resistance) : 주어진 임의의 출력값의 입력값을 찾는 것이 계산적으로 불가능
    3. 약한 충돌저항성
    4. 강한 충돌저항성
### 용도
    1. 전자서명
    2. 메시지 무결성
    3. 패스워드를 안전하게 저장
    4. 공개키 암호시스템
    5. 의사난수 
    6. HMAC
    7. 스팸메일 막는데 사용
    8. 블록체인 원장 무결성
    9. 비트코인 채굴
### 종류
    * 키가 없는
    1. 블록 암호 기초
    2. 전용 해시 함수 : MD4(x) MD5, SHA-256, SHA3
    3. 모듈연산 : 내장된 모듈 연산, 느리다
    4. MDC 조정탐지코드
    * 키가 있는
    5. MAC 메시지 인증코드 Message Authentication Code(암호화 비밀키 사용) - 비밀키를 공유해야 & 무결성+인증 동시에 수행 ==> CBC, HMAC
        - CBC-MAC